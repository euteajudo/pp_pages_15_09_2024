import streamlit as st
import pandas as pd
import os
import sys
from dotenv import load_dotenv
from utils.config import COLUMN_CONFIG, get_column_config
from utils.utils import aplicar_mascara, calcular_estatisticas
from utils.apis import consultar_api_governo_async
from agents_tools.ag_to import criar_agente_dataframe, get_or_create_agent, update_agent
import time
import asyncio
import plotly.express as px
import numpy as np
import altair as alt

# Adicionar o diret√≥rio pai ao sys.path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def limpar_e_converter(valor):
    if isinstance(valor, str):
        # Remove caracteres n√£o num√©ricos, exceto ponto e v√≠rgula
        valor = ''.join(c for c in valor if c.isdigit() or c in ['.', ','])
        # Substitui v√≠rgula por ponto
        valor = valor.replace(',', '.')
    try:
        return float(valor)
    except ValueError:
        return None

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Pesquisa de Pre√ßos",
    page_icon="üè†",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Carregar vari√°veis de ambiente
load_dotenv()

# Configurar a chave da API
os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")

# Configura√ß√£o do Streamlit
st.title("Pesquisa de Pre√ßos")

# Inicializa√ß√£o do estado da conversa
if "messages" not in st.session_state:
    st.session_state.messages = []
if "df" not in st.session_state:
    st.session_state.df = None
if "tempos_resposta" not in st.session_state:
    st.session_state.tempos_resposta = []
if "progress_bar" not in st.session_state:
    st.session_state.progress_bar = st.progress(0)

# Fun√ß√£o para limpar os dados e reiniciar a aplica√ß√£o
def limpar_dados():
    st.session_state.df = None
    st.session_state.tempos_resposta = []
    st.session_state.messages = []
    if "agent" in st.session_state:
        del st.session_state.agent
    st.session_state.agent = None  # Garante que o agente seja None ap√≥s a limpeza

# Sidebar para input de par√¢metros, sele√ß√£o de modelo e bot√£o de limpar hist√≥rico
with st.sidebar:
    st.header("Par√¢metros de Consulta")
    codigo_item = st.text_input("C√≥digo do Item")
    data_inicial = st.date_input("Data Inicial")
    data_final = st.date_input("Data Final")
    st.session_state.model_choice = st.selectbox("Escolha o Modelo", ["gpt-3.5-turbo-0125", "gpt-4o", "gpt-4o-mini"])
    
    if st.button("Buscar Dados"):
        with st.spinner("Buscando dados..."):
            try:
                resultados = asyncio.run(consultar_api_governo_async(codigo_item, data_inicial.strftime("%Y-%m-%d"), data_final.strftime("%Y-%m-%d")))
                if resultados['df'] is not None and not resultados['df'].empty:
                    st.session_state.df = resultados['df']
                    st.session_state.total_registros = resultados['total_registros']
                    st.session_state.total_paginas = resultados['total_paginas']
                    
                    tempo_resposta = time.time() - time.time()
                    st.session_state.tempos_resposta.append(tempo_resposta)
                    
                    st.success(f"Dados carregados com sucesso! Total de registros: {st.session_state.total_registros}")
                else:
                    st.warning("N√£o foram encontrados dados para os par√¢metros fornecidos.")
            except Exception as e:
                st.error(f"Erro ao buscar dados: {str(e)}")
    
    if st.button("Limpar Dados"):
        limpar_dados()
        if "df" in st.session_state and isinstance(st.session_state.df, pd.DataFrame):
            update_agent(st.session_state.df, st.session_state.model_choice)
        st.success("Dados limpos e agente atualizado com sucesso!")

# Cria√ß√£o das tabs
tab1, tab2, tab3 = st.tabs(["Dados", "Par√¢metros", "Gr√°ficos"])

# Fun√ß√£o para obter o nome amig√°vel de uma coluna
def get_friendly_name(col):
    config = COLUMN_CONFIG.get(col, {})
    if isinstance(config, dict) and 'label' in config:
        return config['label']
    elif hasattr(config, 'label'):
        return config.label or col
    else:
        return col.replace('_', ' ').title()

# Fun√ß√£o para aplicar formata√ß√µes ao DataFrame
def aplicar_formatacoes(df):
    for coluna in df.columns:
        if coluna == 'niFornecedor':
            df[coluna] = df[coluna].apply(lambda x: aplicar_mascara(x, 'cnpj'))
        elif coluna == 'precoUnitario':
            df[coluna] = df[coluna].apply(lambda x: aplicar_mascara(x, 'preco'))
        elif coluna == 'quantidade':
            df[coluna] = df[coluna].apply(lambda x: aplicar_mascara(x, 'quantidade'))
        elif coluna == 'codigoItemCatalogo':
            df[coluna] = df[coluna].apply(lambda x: aplicar_mascara(x, 'catmat'))
        elif coluna == 'dataResultado':
            df[coluna] = df[coluna].apply(lambda x: aplicar_mascara(x, 'data'))
    return df

with tab1:
    st.header("Dados brutos")
    if isinstance(st.session_state.df, pd.DataFrame):
        df_formatado = aplicar_formatacoes(st.session_state.df.copy())
        agent = get_or_create_agent(df_formatado, st.session_state.model_choice)
        
        st.dataframe(
            df_formatado,
            use_container_width=True,
            hide_index=True,
            column_config={col: get_column_config(col) for col in df_formatado.columns}
        )
        
        # Container para o hist√≥rico de mensagens
        chat_container = st.container()
        
        # Container para o campo de input fixo no rodap√©
        input_container = st.container()
        
        # Exibir mensagens no container de chat
        with chat_container:
            for message in st.session_state.messages:
                with st.chat_message(message["role"]):
                    st.markdown(message["content"])

        # Campo de input fixo no rodap√©
        with input_container:
            prompt = st.chat_input("Fa√ßa uma pergunta sobre os dados")

        if prompt:
            st.session_state.messages.append({"role": "user", "content": prompt})
            with chat_container:
                with st.chat_message("user"):
                    st.markdown(prompt)

                with st.chat_message("assistant"):
                    message_placeholder = st.empty()
                    full_response = ""
                    with st.spinner("Analisando..."):
                        response = agent.invoke({'input': prompt})
                        full_response = response['output']
                    message_placeholder.markdown(full_response)
            st.session_state.messages.append({"role": "assistant", "content": full_response})
            st.rerun()
    else:
        st.info("Nenhum dado carregado. Use o painel lateral para buscar dados.")

with tab2:
    st.header("Par√¢metros")
    
    if isinstance(st.session_state.df, pd.DataFrame) and 'precoUnitario' in st.session_state.df.columns:
        # Processar a coluna de Pre√ßo Unit√°rio
        preco_unitario = pd.to_numeric(st.session_state.df['precoUnitario'], errors='coerce')
        
        # C√°lculo das estat√≠sticas
        media, limite_inferior, limite_superior = calcular_estatisticas(preco_unitario)
        desvio_padrao = preco_unitario.std()
        cv = (desvio_padrao / media) * 100 if media != 0 else 0

        # Exibi√ß√£o das estat√≠sticas
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric(label="M√©dia do Pre√ßo Unit√°rio", value=f"R$ {media:.2f}")
            st.metric(label="Mediana do Pre√ßo Unit√°rio", value=f"R$ {preco_unitario.median():.2f}")
        with col2:
            st.metric(label="Menor Pre√ßo Unit√°rio", value=f"R$ {preco_unitario.min():.2f}")
            st.metric(label="Limite Inferior", value=f"R$ {limite_inferior:.2f}")
        with col3:
            st.metric(label="Maior Pre√ßo Unit√°rio", value=f"R$ {preco_unitario.max():.2f}")
            st.metric(label="Limite Superior", value=f"R$ {limite_superior:.2f}")
        
        # M√©trica para o Coeficiente de Varia√ß√£o
        cv_delta = "OK" if cv <= 25 else f"{cv - 25:.2f}% acima do limite"
        cv_delta_color = "normal" if cv <= 25 else "inverse"
        st.metric(
            label="Coeficiente de Varia√ß√£o",
            value=f"{cv:.2f}%",
            delta=cv_delta,
            delta_color=cv_delta_color
        )

        # Instru√ß√£o para o usu√°rio sobre o CV
        if cv > 25:
            st.warning("O Coeficiente de Varia√ß√£o est√° acima de 25%. Considere analisar os dados para identificar poss√≠veis outliers.")
        else:
            st.success("O Coeficiente de Varia√ß√£o est√° dentro do limite desejado (25% ou menos).")
    else:
        st.warning("A coluna 'precoUnitario' n√£o foi encontrada nos dados carregados ou nenhum dado foi carregado.")

with tab3:
    st.header("Gr√°ficos")
    
    if isinstance(st.session_state.df, pd.DataFrame):
        if 'quantidade' in st.session_state.df.columns and 'precoUnitario' in st.session_state.df.columns:
            # Converter as colunas para num√©rico
            quantidade = st.session_state.df['quantidade'].apply(limpar_e_converter)
            preco_unitario = st.session_state.df['precoUnitario'].apply(limpar_e_converter)
            
            # Criar DataFrame com dados v√°lidos
            dados_validos = pd.DataFrame({'quantidade': quantidade, 'preco_unitario': preco_unitario})
            dados_validos = dados_validos.replace([np.inf, -np.inf], np.nan).dropna()
            
            if not dados_validos.empty:
                # Gr√°fico de dispers√£o
                fig_correlacao = px.scatter(dados_validos, x='quantidade', y='preco_unitario', 
                                            labels={'quantidade': 'Quantidade', 'preco_unitario': 'Pre√ßo Unit√°rio'},
                                            title="Correla√ß√£o entre Quantidade e Pre√ßo Unit√°rio")
                st.plotly_chart(fig_correlacao, use_container_width=True)
                
                # C√°lculo e exibi√ß√£o da correla√ß√£o
                correlacao = dados_validos['quantidade'].corr(dados_validos['preco_unitario'])
                st.write(f"Coeficiente de correla√ß√£o: {correlacao:.2f}")
                
                # Interpreta√ß√£o da correla√ß√£o
                if correlacao < -0.5:
                    st.success("H√° uma forte correla√ß√£o negativa.")
                elif correlacao > 0.5:
                    st.warning("H√° uma forte correla√ß√£o positiva.")
                else:
                    st.info("N√£o h√° uma correla√ß√£o forte entre quantidade e pre√ßo unit√°rio.")

                # Gr√°fico com linha de tend√™ncia
                try:
                    fig_correlacao_tendencia = px.scatter(dados_validos, x='quantidade', y='preco_unitario', 
                                                          labels={'quantidade': 'Quantidade', 'preco_unitario': 'Pre√ßo Unit√°rio'},
                                                          title="Correla√ß√£o com Linha de Tend√™ncia",
                                                          trendline="ols")
                    st.plotly_chart(fig_correlacao_tendencia, use_container_width=True)
                except Exception as e:
                    st.warning(f"Erro ao gerar gr√°fico com linha de tend√™ncia: {str(e)}")

                # Histograma de pre√ßo unit√°rio
                hist_preco = alt.Chart(dados_validos).mark_bar().encode(
                    alt.X('preco_unitario', bin=alt.Bin(maxbins=30), title='Pre√ßo Unit√°rio (R$)'),
                    alt.Y('count()', title='Contagem'),
                    tooltip=['count()']
                ).properties(
                    title='Distribui√ß√£o do Pre√ßo Unit√°rio',
                    width=600,
                    height=400
                )
                
                # Exibir o gr√°fico
                st.altair_chart(hist_preco, use_container_width=True)

                # Explica√ß√£o adicional sobre o histograma
                st.info("O histograma acima mostra a distribui√ß√£o dos pre√ßos unit√°rios. " 
                        "Cada barra representa um intervalo de pre√ßos, e a altura da barra indica quantos itens est√£o nesse intervalo.")
            else:
                st.warning("N√£o h√° dados v√°lidos para criar os gr√°ficos ap√≥s a limpeza e convers√£o.")
        else:
            st.warning("As colunas 'quantidade' e 'precoUnitario' s√£o necess√°rias para esta an√°lise.")
    else:
        st.info("Nenhum dado carregado. Use o painel lateral para buscar dados.")


